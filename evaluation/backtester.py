"""Walk-forward backtesting engine.

Splits historical data into rolling train/test windows and simulates
trades generated by a strategy's ``generate_signals`` method.  Results
include a full equity curve, individual trade records, and aggregated
performance metrics.
"""

from __future__ import annotations

import logging
from dataclasses import dataclass, field
from typing import Protocol

import pandas as pd

from evaluation.metrics import PerformanceSummary, generate_summary

logger = logging.getLogger(__name__)

# ---------------------------------------------------------------------------
# Signal protocol
# ---------------------------------------------------------------------------


class Signal(Protocol):
    """Minimal interface expected from strategy signals.

    A signal must expose at least the following attributes so that the
    backtester can simulate trade entry/exit.
    """

    ticker: str
    side: str  # "buy" or "sell"
    date: pd.Timestamp


class Strategy(Protocol):
    """Minimal strategy interface consumed by the backtester."""

    def generate_signals(self, data: pd.DataFrame) -> list[Signal]:  # type: ignore[override]
        ...


# ---------------------------------------------------------------------------
# Configuration & result data classes
# ---------------------------------------------------------------------------


@dataclass
class BacktestConfig:
    """Parameters controlling the walk-forward window geometry."""

    train_window_days: int = 252
    test_window_days: int = 63
    step_days: int = 21


@dataclass
class BacktestResult:
    """Output of a single walk-forward backtest run."""

    trades: list[dict] = field(default_factory=list)
    """Each dict has keys: ticker, entry_date, exit_date, side, entry_price,
    exit_price, pnl, return_pct."""

    equity_curve: pd.Series = field(default_factory=lambda: pd.Series(dtype=float))
    metrics: PerformanceSummary = field(
        default_factory=lambda: PerformanceSummary(
            sharpe_ratio=0.0,
            max_drawdown=0.0,
            win_rate=0.0,
            total_pnl=0.0,
            avg_pnl=0.0,
            best_trade=0.0,
            worst_trade=0.0,
            num_trades=0,
        )
    )
    windows_used: int = 0


# ---------------------------------------------------------------------------
# Backtester
# ---------------------------------------------------------------------------

_INITIAL_CAPITAL: float = 100_000.0


class Backtester:
    """Walk-forward backtester.

    For each window the strategy is allowed to see only the test slice.
    Signals are simulated with a simple model: buy at next day's open after
    a buy signal, sell at the next sell signal or at the end of the window.
    """

    def __init__(self, config: BacktestConfig | None = None) -> None:
        self._config = config or BacktestConfig()

    # ------------------------------------------------------------------
    # Public API
    # ------------------------------------------------------------------

    def run(self, strategy: Strategy, data: pd.DataFrame) -> BacktestResult:
        """Execute a walk-forward backtest.

        Parameters
        ----------
        strategy:
            Any object whose ``generate_signals(data)`` method returns a
            list of signal objects with ``ticker``, ``side``, and ``date``
            attributes.
        data:
            OHLCV ``DataFrame`` with a ``DatetimeIndex`` and at least
            ``Open`` and ``Close`` columns.

        Returns
        -------
        BacktestResult
        """
        cfg = self._config
        all_trades: list[dict] = []
        equity: float = _INITIAL_CAPITAL
        equity_points: list[tuple[pd.Timestamp, float]] = []
        windows_used: int = 0

        n_rows = len(data)
        if n_rows < cfg.train_window_days + cfg.test_window_days:
            logger.warning(
                "Not enough data for even one walk-forward window "
                "(%d rows, need %d). Returning empty result.",
                n_rows,
                cfg.train_window_days + cfg.test_window_days,
            )
            return BacktestResult()

        start = 0
        while start + cfg.train_window_days + cfg.test_window_days <= n_rows:
            test_start = start + cfg.train_window_days
            test_end = test_start + cfg.test_window_days
            test_end = min(test_end, n_rows)

            test_data = data.iloc[test_start:test_end].copy()
            if test_data.empty:
                start += cfg.step_days
                continue

            # Roll through the test window day-by-day so strategies that
            # look at the last row emit one signal per bar.
            daily_signals: list[tuple[pd.Timestamp, object]] = []
            for i in range(len(test_data)):
                slice_data = test_data.iloc[: i + 1]
                bar_signals = strategy.generate_signals(slice_data)
                for sig in bar_signals:
                    daily_signals.append((slice_data.index[-1], sig))

            window_trades, equity = self._simulate_window(
                daily_signals, test_data, equity
            )
            all_trades.extend(window_trades)

            # Record equity at end of window.
            last_date = test_data.index[-1]
            equity_points.append((last_date, equity))
            windows_used += 1
            start += cfg.step_days

        # Build equity curve Series.
        if equity_points:
            dates, values = zip(*equity_points)
            equity_curve = pd.Series(values, index=pd.DatetimeIndex(dates), dtype=float)
        else:
            equity_curve = pd.Series(dtype=float)

        metrics = generate_summary(equity_curve, all_trades)

        return BacktestResult(
            trades=all_trades,
            equity_curve=equity_curve,
            metrics=metrics,
            windows_used=windows_used,
        )

    # ------------------------------------------------------------------
    # Simulation helpers
    # ------------------------------------------------------------------

    @staticmethod
    def _simulate_window(
        daily_signals: list[tuple[pd.Timestamp, object]],
        data: pd.DataFrame,
        equity: float,
    ) -> tuple[list[dict], float]:
        """Simulate trades within a single test window.

        Rules
        -----
        - A *buy* signal opens a long position at the next day's open.
        - A *sell* signal (or end-of-window) closes the open position.
        - Only one position is held at a time within a window.
        - Position size is 100 % of current equity (simplified).

        Parameters
        ----------
        daily_signals:
            List of (bar_date, signal) tuples from the day-by-day roll.

        Returns
        -------
        tuple[list[dict], float]
            (list_of_trade_records, updated_equity)
        """
        trades: list[dict] = []
        in_position = False
        entry_price: float = 0.0
        entry_date: pd.Timestamp | None = None
        entry_ticker: str = ""
        shares: float = 0.0

        for sig_date, signal in daily_signals:
            # Determine action â€” support both .action and .side attribute names.
            action: str = getattr(signal, "action", None) or getattr(signal, "side", "")

            # Find the *next* trading day in data after the signal date for
            # execution at the open.
            later_dates = data.index[data.index > sig_date]
            if later_dates.empty:
                continue
            exec_date = later_dates[0]

            if action == "buy" and not in_position:
                entry_price = float(data.loc[exec_date, "Open"])
                if entry_price <= 0:
                    continue
                shares = equity / entry_price
                entry_date = exec_date
                entry_ticker = signal.ticker
                in_position = True

            elif action == "sell" and in_position:
                exit_price = float(data.loc[exec_date, "Open"])
                pnl = (exit_price - entry_price) * shares
                return_pct = (exit_price - entry_price) / entry_price if entry_price else 0.0
                equity += pnl
                trades.append(
                    {
                        "ticker": entry_ticker,
                        "entry_date": str(entry_date),
                        "exit_date": str(exec_date),
                        "side": "long",
                        "entry_price": entry_price,
                        "exit_price": exit_price,
                        "pnl": pnl,
                        "return_pct": return_pct,
                    }
                )
                in_position = False

        # Close any open position at the last close of the window.
        if in_position and not data.empty:
            last_date = data.index[-1]
            exit_price = float(data.loc[last_date, "Close"])
            pnl = (exit_price - entry_price) * shares
            return_pct = (exit_price - entry_price) / entry_price if entry_price else 0.0
            equity += pnl
            trades.append(
                {
                    "ticker": entry_ticker,
                    "entry_date": str(entry_date),
                    "exit_date": str(last_date),
                    "side": "long",
                    "entry_price": entry_price,
                    "exit_price": exit_price,
                    "pnl": pnl,
                    "return_pct": return_pct,
                }
            )

        return trades, equity
