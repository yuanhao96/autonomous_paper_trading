[
  {
    "factor_ref": "/Users/huangyuanhao/projects/autonomous_trading/factors/cross_sectional/wq_001.md",
    "name": "WQ-001: Ranked conditional volatility argmax",
    "category": "cross_sectional",
    "formula": "rank(ts_argmax(SignedPower(where(returns < 0, stddev(returns, 20), close), 2), 5)) - 0.5",
    "verdict": "FAIL",
    "reasons": [
      "FAIL: |IC| 0.0088 < 0.01"
    ],
    "error": null,
    "metrics": {
      "mean_ic": -0.008786190574717995,
      "ic_t_stat": -0.9783775921901916,
      "monotonicity": 0.5,
      "long_short_spread": 0.0060799525635877325,
      "group_mean_returns": {
        "1": -0.0024185145335055575,
        "2": -0.0026890696204193002,
        "3": 0.003661438030082175
      },
      "n_groups": 3
    },
    "params": {
      "vol_lookback": 20,
      "argmax_lookback": 5
    },
    "param_ranges": {
      "vol_lookback": [
        10,
        30
      ],
      "argmax_lookback": [
        3,
        10
      ]
    },
    "code": "import numpy as np\nimport pandas as pd\n\ndef compute_alpha(universe_data: dict[str, pd.DataFrame], **params) -> pd.DataFrame:\n    \"\"\"Returns DataFrame(index=dates, columns=tickers, values=alpha).\"\"\"\n    vol_lookback = params.get(\"vol_lookback\", 20)\n    argmax_lookback = params.get(\"argmax_lookback\", 5)\n\n    close = pd.DataFrame({t: d[\"Close\"] for t, d in universe_data.items()})\n    volume = pd.DataFrame({t: d[\"Volume\"] for t, d in universe_data.items()}).astype(float)\n\n    close, volume = close.align(volume, join=\"inner\", axis=0)\n\n    returns = close.pct_change(1)\n\n    vol = returns.rolling(vol_lookback).std()\n\n    cond = returns < 0\n    base = pd.DataFrame(np.where(cond.values, vol.values, close.values), index=close.index, columns=close.columns)\n\n    signed_power = np.sign(base) * (np.abs(base) ** 2)\n\n    argmax_ts = signed_power.rolling(argmax_lookback).apply(lambda s: s.argmax(), raw=True)\n\n    alpha = argmax_ts.rank(axis=1, pct=True) - 0.5\n\n    alpha = alpha.reindex_like(close)\n    return alpha.dropna(how=\"all\")"
  },
  {
    "factor_ref": "/Users/huangyuanhao/projects/autonomous_trading/factors/cross_sectional/wq_006.md",
    "name": "WQ-006: Open-volume rank correlation",
    "category": "cross_sectional",
    "formula": "-1 * correlation(rank(open), rank(volume), 10)",
    "verdict": "MARGINAL",
    "reasons": [
      "MARGINAL: |IC| 0.0214 < 0.03",
      "MARGINAL: |t-stat| 1.81 < 2.0",
      "MARGINAL: L/S spread -0.0001 <= 0"
    ],
    "error": null,
    "metrics": {
      "mean_ic": -0.021419891876979753,
      "ic_t_stat": -1.8121780576477962,
      "monotonicity": 0.5,
      "long_short_spread": -8.243944981911535e-05,
      "group_mean_returns": {
        "1": 0.0006459105766951514,
        "2": 0.0008443346251172505,
        "3": 0.000563471126876036
      },
      "n_groups": 3
    },
    "params": {
      "lookback": 10
    },
    "param_ranges": {
      "lookback": [
        5,
        20
      ]
    },
    "code": "import numpy as np\nimport pandas as pd\n\ndef compute_alpha(universe_data: dict[str, pd.DataFrame], **params) -> pd.DataFrame:\n    \"\"\"Returns DataFrame(index=dates, columns=tickers, values=alpha).\"\"\"\n    lookback = int(params.get(\"lookback\", 10))\n\n    open_ = pd.DataFrame({t: d[\"Open\"] for t, d in universe_data.items()})\n    volume = pd.DataFrame({t: d[\"Volume\"] for t, d in universe_data.items()}).astype(float)\n\n    open_, volume = open_.align(volume, join=\"inner\", axis=0)\n\n    rank_open = open_.rank(axis=1, pct=True)\n    rank_volume = volume.rank(axis=1, pct=True)\n\n    alpha = -1.0 * rank_open.rolling(lookback).corr(rank_volume)\n\n    alpha = alpha.reindex_like(open_)\n    return alpha.dropna(how=\"all\")"
  },
  {
    "factor_ref": "/Users/huangyuanhao/projects/autonomous_trading/factors/cross_sectional/wq_008.md",
    "name": "WQ-008: Ranked midpoint price acceleration",
    "category": "cross_sectional",
    "formula": "-1 * rank(delta(close * 0.5 + open * 0.5, 4) - delta(close * 0.5 + open * 0.5, 8))",
    "verdict": "FAIL",
    "reasons": [
      "FAIL: |IC| 0.0035 < 0.01",
      "FAIL: monotonicity 0.00 < 0.50"
    ],
    "error": null,
    "metrics": {
      "mean_ic": -0.003538715736751947,
      "ic_t_stat": -0.3813507250276905,
      "monotonicity": 0.0,
      "long_short_spread": -9.165478554376473e-05,
      "group_mean_returns": {
        "1": 0.0006381136641045788,
        "2": 0.0005989098458689183,
        "3": 0.000546458878560814
      },
      "n_groups": 3
    },
    "params": {
      "short_delta": 4,
      "long_delta": 8
    },
    "param_ranges": {
      "short_delta": [
        2,
        6
      ],
      "long_delta": [
        6,
        12
      ]
    },
    "code": "import numpy as np\nimport pandas as pd\n\ndef compute_alpha(universe_data: dict[str, pd.DataFrame], **params) -> pd.DataFrame:\n    \"\"\"Returns DataFrame(index=dates, columns=tickers, values=alpha).\"\"\"\n    short_delta = params.get(\"short_delta\", 4)\n    long_delta = params.get(\"long_delta\", 8)\n\n    close = pd.DataFrame({t: d[\"Close\"] for t, d in universe_data.items()})\n    open_ = pd.DataFrame({t: d[\"Open\"] for t, d in universe_data.items()})\n\n    close, open_ = close.align(open_, join=\"inner\", axis=0)\n\n    midpoint = 0.5 * close + 0.5 * open_\n    accel = midpoint.diff(short_delta) - midpoint.diff(long_delta)\n    alpha = -1.0 * accel.rank(axis=1, pct=True)\n\n    return alpha.dropna(how=\"all\")"
  },
  {
    "factor_ref": "/Users/huangyuanhao/projects/autonomous_trading/factors/cross_sectional/wq_010.md",
    "name": "WQ-010: Ranked conditional momentum/reversal",
    "category": "cross_sectional",
    "formula": "rank(where(ts_min(delta(close, 1), 4) > 0, delta(close, 1), where(ts_max(delta(close, 1), 4) < 0, delta(close, 1), -1 * delta(close, 1))))",
    "verdict": "FAIL",
    "reasons": [
      "FAIL: |IC| 0.0003 < 0.01",
      "FAIL: monotonicity 0.00 < 0.50"
    ],
    "error": null,
    "metrics": {
      "mean_ic": -0.0002607163421984112,
      "ic_t_stat": -0.02953027054945995,
      "monotonicity": 0.0,
      "long_short_spread": -0.011039526456158836,
      "group_mean_returns": {
        "1": 0.006640618995949528,
        "2": 0.0010931074742655937,
        "3": -0.004398907460209308
      },
      "n_groups": 3
    },
    "params": {
      "lookback": 4
    },
    "param_ranges": {
      "lookback": [
        2,
        8
      ]
    },
    "code": "import numpy as np\nimport pandas as pd\n\ndef compute_alpha(universe_data: dict[str, pd.DataFrame], **params) -> pd.DataFrame:\n    \"\"\"Returns DataFrame(index=dates, columns=tickers, values=alpha).\"\"\"\n    lookback = params.get(\"lookback\", 4)\n\n    close = pd.DataFrame({t: d[\"Close\"] for t, d in universe_data.items()})\n\n    d1 = close.diff(1)\n\n    tsmin = d1.rolling(lookback).min()\n    tsmax = d1.rolling(lookback).max()\n\n    inner = pd.DataFrame(\n        np.where(tsmax < 0, d1, -1.0 * d1),\n        index=close.index,\n        columns=close.columns,\n    )\n    cond = pd.DataFrame(\n        np.where(tsmin > 0, d1, inner),\n        index=close.index,\n        columns=close.columns,\n    )\n\n    alpha = cond.rank(axis=1, pct=True)\n    return alpha.dropna(how=\"all\")"
  },
  {
    "factor_ref": "/Users/huangyuanhao/projects/autonomous_trading/factors/cross_sectional/wq_013.md",
    "name": "WQ-013: Ranked close-volume rank covariance",
    "category": "cross_sectional",
    "formula": "-1 * rank(covariance(rank(close), rank(volume), 5))",
    "verdict": "FAIL",
    "reasons": [
      "FAIL: |IC| 0.0048 < 0.01"
    ],
    "error": null,
    "metrics": {
      "mean_ic": -0.00477649586738988,
      "ic_t_stat": -0.6120876854906199,
      "monotonicity": 0.5,
      "long_short_spread": -0.0003190071269010391,
      "group_mean_returns": {
        "1": 0.0008430257871570411,
        "2": 0.0004983771740416869,
        "3": 0.000524018660256002
      },
      "n_groups": 3
    },
    "params": {
      "lookback": 5
    },
    "param_ranges": {
      "lookback": [
        3,
        10
      ]
    },
    "code": "import numpy as np\nimport pandas as pd\n\ndef compute_alpha(universe_data: dict[str, pd.DataFrame], **params) -> pd.DataFrame:\n    \"\"\"Returns DataFrame(index=dates, columns=tickers, values=alpha).\"\"\"\n    lookback = int(params.get(\"lookback\", 5))\n\n    close = pd.DataFrame({t: d[\"Close\"] for t, d in universe_data.items()})\n    volume = pd.DataFrame({t: d[\"Volume\"] for t, d in universe_data.items()}).astype(float)\n\n    close, volume = close.align(volume, join=\"inner\", axis=0)\n\n    rank_close = close.rank(axis=1, pct=True)\n    rank_volume = volume.rank(axis=1, pct=True)\n\n    cov = rank_close.rolling(lookback).cov(rank_volume)\n    alpha = -1.0 * cov.rank(axis=1, pct=True)\n\n    alpha = alpha.reindex_like(close)\n    return alpha.dropna(how=\"all\")"
  },
  {
    "factor_ref": "/Users/huangyuanhao/projects/autonomous_trading/factors/cross_sectional/wq_016.md",
    "name": "WQ-016: Ranked high-volume rank covariance",
    "category": "cross_sectional",
    "formula": "-1 * rank(covariance(rank(high), rank(volume), 5))",
    "verdict": "FAIL",
    "reasons": [
      "FAIL: |IC| 0.0085 < 0.01"
    ],
    "error": null,
    "metrics": {
      "mean_ic": -0.008548459175016144,
      "ic_t_stat": -1.1087491077179987,
      "monotonicity": 0.5,
      "long_short_spread": -0.00033070772622641794,
      "group_mean_returns": {
        "1": 0.0008509262314710081,
        "2": 0.0004526445039590411,
        "3": 0.0005202185052445901
      },
      "n_groups": 3
    },
    "params": {
      "lookback": 5
    },
    "param_ranges": {
      "lookback": [
        3,
        10
      ]
    },
    "code": "import numpy as np\nimport pandas as pd\n\ndef compute_alpha(universe_data: dict[str, pd.DataFrame], **params) -> pd.DataFrame:\n    \"\"\"Returns DataFrame(index=dates, columns=tickers, values=alpha).\"\"\"\n    lookback = int(params.get(\"lookback\", 5))\n\n    high = pd.DataFrame({t: d[\"High\"] for t, d in universe_data.items()})\n    volume = pd.DataFrame({t: d[\"Volume\"] for t, d in universe_data.items()}).astype(float)\n\n    high, volume = high.align(volume, join=\"inner\", axis=0)\n\n    rank_high = high.rank(axis=1, pct=True)\n    rank_vol = volume.rank(axis=1, pct=True)\n\n    cov = rank_high.rolling(lookback).cov(rank_vol)\n\n    alpha = -1.0 * cov.rank(axis=1, pct=True)\n\n    return alpha.dropna(how=\"all\")"
  },
  {
    "factor_ref": "/Users/huangyuanhao/projects/autonomous_trading/factors/cross_sectional/wq_022.md",
    "name": "WQ-022: Change in high-volume correlation weighted by ranked volatility",
    "category": "cross_sectional",
    "formula": "-1 * delta(correlation(high, volume, 5), 5) * rank(stddev(close, 20))",
    "verdict": "FAIL",
    "reasons": [
      "FAIL: |IC| 0.0029 < 0.01",
      "FAIL: monotonicity 0.00 < 0.50"
    ],
    "error": null,
    "metrics": {
      "mean_ic": 0.002880430941453734,
      "ic_t_stat": 0.3515976546904819,
      "monotonicity": 0.0,
      "long_short_spread": -0.0011274144894983277,
      "group_mean_returns": {
        "1": 0.0011989691171187904,
        "2": 0.0006331847735370329,
        "3": 7.155462762046272e-05
      },
      "n_groups": 3
    },
    "params": {
      "corr_lookback": 5,
      "delta_lookback": 5,
      "vol_lookback": 20
    },
    "param_ranges": {
      "corr_lookback": [
        3,
        10
      ],
      "delta_lookback": [
        3,
        10
      ],
      "vol_lookback": [
        10,
        30
      ]
    },
    "code": "import numpy as np\nimport pandas as pd\n\ndef compute_alpha(universe_data: dict[str, pd.DataFrame], **params) -> pd.DataFrame:\n    \"\"\"Returns DataFrame(index=dates, columns=tickers, values=alpha).\"\"\"\n    corr_lookback = params.get(\"corr_lookback\", 5)\n    delta_lookback = params.get(\"delta_lookback\", 5)\n    vol_lookback = params.get(\"vol_lookback\", 20)\n\n    close = pd.DataFrame({t: d[\"Close\"] for t, d in universe_data.items()})\n    high = pd.DataFrame({t: d[\"High\"] for t, d in universe_data.items()})\n    volume = pd.DataFrame({t: d[\"Volume\"] for t, d in universe_data.items()}).astype(float)\n\n    corr_hv = high.rolling(corr_lookback).corr(volume)\n    delta_corr = corr_hv.diff(delta_lookback)\n\n    vol = close.rolling(vol_lookback).std()\n    ranked_vol = vol.rank(axis=1, pct=True)\n\n    alpha = -1.0 * delta_corr * ranked_vol\n\n    alpha = alpha.reindex_like(close)\n    alpha = alpha.dropna(how=\"all\")\n    return alpha"
  },
  {
    "factor_ref": "/Users/huangyuanhao/projects/autonomous_trading/factors/cross_sectional/wq_030.md",
    "name": "WQ-030: Ranked directional persistence times volume ratio",
    "category": "cross_sectional",
    "formula": "rank(sign(close - delay(close, 1)) + sign(delay(close, 1) - delay(close, 2)) + sign(delay(close, 2) - delay(close, 3))) * sum(volume, 5) / sum(volume, 20)",
    "verdict": "FAIL",
    "reasons": [
      "FAIL: |IC| 0.0090 < 0.01"
    ],
    "error": null,
    "metrics": {
      "mean_ic": -0.008988718865065654,
      "ic_t_stat": -1.0495715840377058,
      "monotonicity": 1.0,
      "long_short_spread": 0.005620369433397117,
      "group_mean_returns": {
        "1": -0.002397670433475931,
        "2": 0.00017952006418235202,
        "3": 0.0032226989999211853
      },
      "n_groups": 3
    },
    "params": {
      "short_vol": 5,
      "long_vol": 20
    },
    "param_ranges": {
      "short_vol": [
        3,
        10
      ],
      "long_vol": [
        10,
        40
      ]
    },
    "code": "import numpy as np\nimport pandas as pd\n\ndef compute_alpha(universe_data: dict[str, pd.DataFrame], **params) -> pd.DataFrame:\n    \"\"\"Returns DataFrame(index=dates, columns=tickers, values=alpha).\"\"\"\n    short_vol = params.get(\"short_vol\", 5)\n    long_vol = params.get(\"long_vol\", 20)\n\n    close = pd.DataFrame({t: d[\"Close\"] for t, d in universe_data.items()})\n    volume = pd.DataFrame({t: d[\"Volume\"] for t, d in universe_data.items()}).astype(float)\n\n    close, volume = close.align(volume, join=\"inner\", axis=0)\n\n    d1 = close.shift(1)\n    d2 = close.shift(2)\n    d3 = close.shift(3)\n\n    persistence = np.sign(close - d1) + np.sign(d1 - d2) + np.sign(d2 - d3)\n    ranked_persistence = persistence.rank(axis=1, pct=True)\n\n    vol_short = volume.rolling(short_vol).sum()\n    vol_long = volume.rolling(long_vol).sum()\n\n    alpha = ranked_persistence * (vol_short / (vol_long + 1e-8))\n    return alpha.dropna(how=\"all\")"
  },
  {
    "factor_ref": "/Users/huangyuanhao/projects/autonomous_trading/factors/cross_sectional/wq_033.md",
    "name": "WQ-033: Ranked intraday return",
    "category": "cross_sectional",
    "formula": "rank(-1 * (1 - open / close))",
    "verdict": "FAIL",
    "reasons": [
      "FAIL: monotonicity 0.00 < 0.50"
    ],
    "error": null,
    "metrics": {
      "mean_ic": 0.012615686850287166,
      "ic_t_stat": 1.3313729667683842,
      "monotonicity": 0.0,
      "long_short_spread": -0.014193433427772299,
      "group_mean_returns": {
        "1": 0.008273507994358408,
        "2": 0.0013917905377419143,
        "3": -0.005919925433413891
      },
      "n_groups": 3
    },
    "params": {},
    "param_ranges": {},
    "code": "import numpy as np\nimport pandas as pd\n\ndef compute_alpha(universe_data: dict[str, pd.DataFrame], **params) -> pd.DataFrame:\n    \"\"\"Returns DataFrame(index=dates, columns=tickers, values=alpha).\"\"\"\n    close = pd.DataFrame({t: d[\"Close\"] for t, d in universe_data.items()})\n    open_ = pd.DataFrame({t: d[\"Open\"] for t, d in universe_data.items()})\n\n    close, open_ = close.align(open_, join=\"inner\", axis=0)\n\n    x = -1.0 * (1.0 - open_ / (close + 1e-8))\n    alpha = x.rank(axis=1, pct=True)\n\n    return alpha.dropna(how=\"all\")"
  },
  {
    "factor_ref": "/Users/huangyuanhao/projects/autonomous_trading/factors/cross_sectional/wq_037.md",
    "name": "WQ-037: Ranked long-term correlation plus ranked intraday return",
    "category": "cross_sectional",
    "formula": "rank(correlation(delay(open - close, 1), close, 200)) + rank(open - close)",
    "verdict": "FAIL",
    "reasons": [
      "FAIL: |IC| 0.0093 < 0.01",
      "FAIL: monotonicity 0.00 < 0.50"
    ],
    "error": null,
    "metrics": {
      "mean_ic": 0.009322701798511633,
      "ic_t_stat": 0.9796148036675216,
      "monotonicity": 0.0,
      "long_short_spread": -0.008125226310044337,
      "group_mean_returns": {
        "1": 0.004874262084113846,
        "2": 0.0011919693914292583,
        "3": -0.0032509642259304903
      },
      "n_groups": 3
    },
    "params": {
      "corr_lookback": 200
    },
    "param_ranges": {
      "corr_lookback": [
        100,
        250
      ]
    },
    "code": "import numpy as np\nimport pandas as pd\n\ndef compute_alpha(universe_data: dict[str, pd.DataFrame], **params) -> pd.DataFrame:\n    \"\"\"Returns DataFrame(index=dates, columns=tickers, values=alpha).\"\"\"\n    corr_lookback = params.get(\"corr_lookback\", 200)\n\n    close = pd.DataFrame({t: d[\"Close\"] for t, d in universe_data.items()})\n    open_ = pd.DataFrame({t: d[\"Open\"] for t, d in universe_data.items()})\n\n    close, open_ = close.align(open_, join=\"inner\", axis=0)\n\n    oc = open_ - close\n    delayed_oc = oc.shift(1)\n\n    corr = delayed_oc.rolling(corr_lookback).corr(close)\n    alpha = corr.rank(axis=1, pct=True) + oc.rank(axis=1, pct=True)\n\n    return alpha.dropna(how=\"all\")"
  },
  {
    "factor_ref": "/Users/huangyuanhao/projects/autonomous_trading/factors/cross_sectional/wq_044.md",
    "name": "WQ-044: High vs ranked volume correlation",
    "category": "cross_sectional",
    "formula": "-1 * correlation(high, rank(volume), 5)",
    "verdict": "FAIL",
    "reasons": [
      "FAIL: |IC| 0.0022 < 0.01",
      "FAIL: monotonicity 0.00 < 0.50"
    ],
    "error": null,
    "metrics": {
      "mean_ic": 0.002223774377356554,
      "ic_t_stat": 0.283938102512356,
      "monotonicity": 0.0,
      "long_short_spread": -0.001243869141786225,
      "group_mean_returns": {
        "1": 0.0012429427312638474,
        "2": 0.0007538998087390429,
        "3": -9.264105223776079e-07
      },
      "n_groups": 3
    },
    "params": {
      "lookback": 5
    },
    "param_ranges": {
      "lookback": [
        3,
        10
      ]
    },
    "code": "import numpy as np\nimport pandas as pd\n\ndef compute_alpha(universe_data: dict[str, pd.DataFrame], **params) -> pd.DataFrame:\n    \"\"\"Returns DataFrame(index=dates, columns=tickers, values=alpha).\"\"\"\n    lookback = int(params.get(\"lookback\", 5))\n\n    high = pd.DataFrame({t: d[\"High\"] for t, d in universe_data.items()})\n    volume = pd.DataFrame({t: d[\"Volume\"] for t, d in universe_data.items()}).astype(float)\n\n    high, volume = high.align(volume, join=\"inner\", axis=0)\n\n    ranked_volume = volume.rank(axis=1, pct=True)\n    corr = high.rolling(lookback).corr(ranked_volume)\n\n    alpha = -1.0 * corr\n    return alpha.dropna(how=\"all\")"
  },
  {
    "factor_ref": "/Users/huangyuanhao/projects/autonomous_trading/factors/cross_sectional/wq_045.md",
    "name": "WQ-045: Triple-factor ranked product",
    "category": "cross_sectional",
    "formula": "-1 * rank(sma(delay(close, 5), 20)) * correlation(close, volume, 2) * rank(correlation(sum(close, 5), sum(close, 20), 2))",
    "verdict": "FAIL",
    "reasons": [
      "FAIL: |IC| 0.0074 < 0.01",
      "FAIL: monotonicity 0.00 < 0.50"
    ],
    "error": null,
    "metrics": {
      "mean_ic": 0.007381152573929167,
      "ic_t_stat": 0.9425364273797407,
      "monotonicity": 0.0,
      "long_short_spread": -0.001765907033817917,
      "group_mean_returns": {
        "1": 0.001541848441641646,
        "2": 0.0006384319672499768,
        "3": -0.00022405859217627095
      },
      "n_groups": 3
    },
    "params": {
      "delay_d": 5,
      "sma_d": 20,
      "corr_d": 2
    },
    "param_ranges": {
      "delay_d": [
        3,
        10
      ],
      "sma_d": [
        10,
        30
      ],
      "corr_d": [
        2,
        5
      ]
    },
    "code": "import numpy as np\nimport pandas as pd\n\ndef compute_alpha(universe_data: dict[str, pd.DataFrame], **params) -> pd.DataFrame:\n    \"\"\"Returns DataFrame(index=dates, columns=tickers, values=alpha).\"\"\"\n    delay_d = params.get(\"delay_d\", 5)\n    sma_d = params.get(\"sma_d\", 20)\n    corr_d = params.get(\"corr_d\", 2)\n\n    close = pd.DataFrame({t: d[\"Close\"] for t, d in universe_data.items()})\n    volume = pd.DataFrame({t: d[\"Volume\"] for t, d in universe_data.items()}).astype(float)\n\n    # rank(sma(delay(close, 5), 20))\n    term1 = close.shift(delay_d).rolling(sma_d).mean()\n    term1_rank = term1.rank(axis=1, pct=True)\n\n    # correlation(close, volume, 2)\n    term2_corr = close.rolling(corr_d).corr(volume)\n\n    # rank(correlation(sum(close, 5), sum(close, 20), 2))\n    sum5 = close.rolling(5).sum()\n    sum20 = close.rolling(20).sum()\n    term3_corr = sum5.rolling(corr_d).corr(sum20)\n    term3_rank = term3_corr.rank(axis=1, pct=True)\n\n    alpha = -1.0 * term1_rank * term2_corr * term3_rank\n\n    alpha = alpha.replace([np.inf, -np.inf], np.nan).dropna(how=\"all\")\n    return alpha"
  },
  {
    "factor_ref": "/Users/huangyuanhao/projects/autonomous_trading/factors/cross_sectional/wq_090.md",
    "name": "WQ-090: Ranked serial correlation times ranked SMA deviation",
    "category": "cross_sectional",
    "formula": "-1 * rank(correlation(delay(close, 1), close, 5)) * rank(close - sma(close, 20) / sma(close, 60))",
    "verdict": "FAIL",
    "reasons": [
      "FAIL: monotonicity 0.00 < 0.50"
    ],
    "error": null,
    "metrics": {
      "mean_ic": -0.016735655631103737,
      "ic_t_stat": -1.9784511011138564,
      "monotonicity": 0.0,
      "long_short_spread": -0.0006478793423955926,
      "group_mean_returns": {
        "1": 0.0009151957249131292,
        "2": 0.0005753606000752673,
        "3": 0.00026731638251753666
      },
      "n_groups": 3
    },
    "params": {
      "corr_lookback": 5,
      "short_sma": 20,
      "long_sma": 60
    },
    "param_ranges": {
      "corr_lookback": [
        3,
        10
      ],
      "short_sma": [
        10,
        30
      ],
      "long_sma": [
        40,
        80
      ]
    },
    "code": "import numpy as np\nimport pandas as pd\n\ndef compute_alpha(universe_data: dict[str, pd.DataFrame], **params) -> pd.DataFrame:\n    \"\"\"Returns DataFrame(index=dates, columns=tickers, values=alpha).\"\"\"\n    corr_lookback = params.get(\"corr_lookback\", 5)\n    short_sma = params.get(\"short_sma\", 20)\n    long_sma = params.get(\"long_sma\", 60)\n\n    close = pd.DataFrame({t: d[\"Close\"] for t, d in universe_data.items()}).sort_index()\n\n    # rank(correlation(delay(close, 1), close, corr_lookback))\n    close_lag1 = close.shift(1)\n    corr_term = close_lag1.rolling(corr_lookback).corr(close)\n    rank_corr = corr_term.rank(axis=1, pct=True)\n\n    # rank(close - sma(close, short_sma) / sma(close, long_sma))\n    sma_short = close.rolling(short_sma).mean()\n    sma_long = close.rolling(long_sma).mean()\n    dev_term = close - (sma_short / (sma_long + 1e-8))\n    rank_dev = dev_term.rank(axis=1, pct=True)\n\n    alpha = -1.0 * rank_corr * rank_dev\n    alpha = alpha.reindex_like(close)\n    return alpha.dropna(how=\"all\")"
  },
  {
    "factor_ref": "/Users/huangyuanhao/projects/autonomous_trading/factors/cross_sectional/wq_099.md",
    "name": "WQ-099: Ranked close-volume rank covariance (variant)",
    "category": "cross_sectional",
    "formula": "-1 * rank(covariance(rank(close), rank(volume), 5))",
    "verdict": "FAIL",
    "reasons": [
      "FAIL: |IC| 0.0048 < 0.01"
    ],
    "error": null,
    "metrics": {
      "mean_ic": -0.00477649586738988,
      "ic_t_stat": -0.6120876854906199,
      "monotonicity": 0.5,
      "long_short_spread": -0.0003190071269010391,
      "group_mean_returns": {
        "1": 0.0008430257871570411,
        "2": 0.0004983771740416869,
        "3": 0.000524018660256002
      },
      "n_groups": 3
    },
    "params": {
      "lookback": 5
    },
    "param_ranges": {
      "lookback": [
        3,
        10
      ]
    },
    "code": "import numpy as np\nimport pandas as pd\n\ndef compute_alpha(universe_data: dict[str, pd.DataFrame], **params) -> pd.DataFrame:\n    \"\"\"Returns DataFrame(index=dates, columns=tickers, values=alpha).\"\"\"\n    lookback = int(params.get(\"lookback\", 5))\n\n    close = pd.DataFrame({t: d[\"Close\"] for t, d in universe_data.items()})\n    volume = pd.DataFrame({t: d[\"Volume\"] for t, d in universe_data.items()}).astype(float)\n\n    close, volume = close.align(volume, join=\"inner\", axis=0)\n\n    r_close = close.rank(axis=1, pct=True)\n    r_vol = volume.rank(axis=1, pct=True)\n\n    cov = r_close.rolling(lookback).cov(r_vol)\n    alpha = -1.0 * cov.rank(axis=1, pct=True)\n\n    return alpha.dropna(how=\"all\")"
  },
  {
    "factor_ref": "/Users/huangyuanhao/projects/autonomous_trading/factors/cross_sectional/wq_115.md",
    "name": "WQ-115: Product of two ranked correlations",
    "category": "cross_sectional",
    "formula": "rank(correlation(high * 0.9 + close * 0.1, sma(volume, 30), 10)) * rank(correlation(ts_rank(high + low / 2, 3), ts_rank(volume, 10), 7))",
    "verdict": "MARGINAL",
    "reasons": [
      "MARGINAL: |IC| 0.0204 < 0.03"
    ],
    "error": null,
    "metrics": {
      "mean_ic": -0.020448048030756612,
      "ic_t_stat": -2.391312243002703,
      "monotonicity": 1.0,
      "long_short_spread": 0.000797091823576117,
      "group_mean_returns": {
        "1": 8.369425978889412e-05,
        "2": 0.0005812213214825647,
        "3": 0.0008807860833650111
      },
      "n_groups": 3
    },
    "params": {
      "vol_sma": 30,
      "corr1_lookback": 10,
      "ts_rank1": 3,
      "ts_rank2": 10,
      "corr2_lookback": 7
    },
    "param_ranges": {
      "vol_sma": [
        15,
        45
      ],
      "corr1_lookback": [
        5,
        20
      ],
      "ts_rank1": [
        2,
        5
      ],
      "ts_rank2": [
        5,
        15
      ],
      "corr2_lookback": [
        5,
        15
      ]
    },
    "code": "import numpy as np\nimport pandas as pd\n\ndef compute_alpha(universe_data: dict[str, pd.DataFrame], **params) -> pd.DataFrame:\n    \"\"\"Returns DataFrame(index=dates, columns=tickers, values=alpha).\"\"\"\n    vol_sma = params.get(\"vol_sma\", 30)\n    corr1_lookback = params.get(\"corr1_lookback\", 10)\n    ts_rank1 = params.get(\"ts_rank1\", 3)\n    ts_rank2 = params.get(\"ts_rank2\", 10)\n    corr2_lookback = params.get(\"corr2_lookback\", 7)\n\n    close = pd.DataFrame({t: d[\"Close\"] for t, d in universe_data.items()})\n    high = pd.DataFrame({t: d[\"High\"] for t, d in universe_data.items()})\n    low = pd.DataFrame({t: d[\"Low\"] for t, d in universe_data.items()})\n    volume = pd.DataFrame({t: d[\"Volume\"] for t, d in universe_data.items()}).astype(float)\n\n    # Align on shared index\n    idx = close.index\n    for df in (high, low, volume):\n        idx = idx.intersection(df.index)\n    close = close.loc[idx].sort_index()\n    high = high.loc[idx].sort_index()\n    low = low.loc[idx].sort_index()\n    volume = volume.loc[idx].sort_index()\n\n    def ts_rank(x: pd.DataFrame, d: int) -> pd.DataFrame:\n        return x.rolling(d).apply(lambda s: s.rank().iloc[-1] / len(s), raw=False)\n\n    # First term: rank(correlation(high * 0.9 + close * 0.1, sma(volume, 30), 10))\n    x1 = high * 0.9 + close * 0.1\n    y1 = volume.rolling(vol_sma).mean()\n    corr1 = x1.rolling(corr1_lookback).corr(y1)\n    term1 = corr1.rank(axis=1, pct=True)\n\n    # Second term: rank(correlation(ts_rank(high + low / 2, 3), ts_rank(volume, 10), 7))\n    x2 = ts_rank(high + low / 2.0, ts_rank1)\n    y2 = ts_rank(volume, ts_rank2)\n    corr2 = x2.rolling(corr2_lookback).corr(y2)\n    term2 = corr2.rank(axis=1, pct=True)\n\n    alpha = term1 * term2\n    return alpha.dropna(how=\"all\")"
  },
  {
    "factor_ref": "/Users/huangyuanhao/projects/autonomous_trading/factors/cross_sectional/wq_157.md",
    "name": "WQ-157: Deeply nested rank composition",
    "category": "cross_sectional",
    "formula": "min(product(rank(rank(log(sum(ts_min(rank(-1 * rank(delta(close - 1, 5))), 2), 1)))), 1), 5) + ts_rank(delay(-1 * returns, 6), 5)",
    "verdict": "FAIL",
    "reasons": [
      "FAIL: monotonicity 0.00 < 0.50"
    ],
    "error": null,
    "metrics": {
      "mean_ic": 0.016660688032790964,
      "ic_t_stat": 1.8973175167409335,
      "monotonicity": 0.0,
      "long_short_spread": -0.0009167458896637295,
      "group_mean_returns": {
        "1": 0.001024939998577895,
        "2": 0.0007146615714866305,
        "3": 0.0001081941089141655
      },
      "n_groups": 3
    },
    "params": {
      "delta_d": 5,
      "ts_min_d": 2,
      "ts_rank_d": 5,
      "delay_d": 6
    },
    "param_ranges": {
      "delta_d": [
        3,
        8
      ],
      "ts_min_d": [
        2,
        4
      ],
      "ts_rank_d": [
        3,
        8
      ],
      "delay_d": [
        4,
        8
      ]
    },
    "code": "import numpy as np\nimport pandas as pd\n\ndef compute_alpha(universe_data: dict[str, pd.DataFrame], **params) -> pd.DataFrame:\n    \"\"\"Returns DataFrame(index=dates, columns=tickers, values=alpha).\"\"\"\n    delta_d = params.get(\"delta_d\", 5)\n    ts_min_d = params.get(\"ts_min_d\", 2)\n    ts_rank_d = params.get(\"ts_rank_d\", 5)\n    delay_d = params.get(\"delay_d\", 6)\n\n    close = pd.DataFrame({t: d[\"Close\"] for t, d in universe_data.items()})\n    open_ = pd.DataFrame({t: d[\"Open\"] for t, d in universe_data.items()})\n    high = pd.DataFrame({t: d[\"High\"] for t, d in universe_data.items()})\n    low = pd.DataFrame({t: d[\"Low\"] for t, d in universe_data.items()})\n    volume = pd.DataFrame({t: d[\"Volume\"] for t, d in universe_data.items()}).astype(float)\n\n    # Align on shared index\n    idx = close.index\n    for df in (open_, high, low, volume):\n        idx = idx.intersection(df.index)\n    close = close.loc[idx].sort_index()\n    open_ = open_.loc[idx].sort_index()\n    high = high.loc[idx].sort_index()\n    low = low.loc[idx].sort_index()\n    volume = volume.loc[idx].sort_index()\n\n    returns = close.pct_change(1)\n\n    # Inner nested expression:\n    # rank(-1 * rank(delta(close - 1, 5)))\n    x0 = close - 1.0\n    x1 = x0.diff(delta_d)\n    x2 = x1.rank(axis=1, pct=True)\n    x3 = (-1.0 * x2).rank(axis=1, pct=True)\n\n    # ts_min(..., 2)\n    x4 = x3.rolling(ts_min_d).min()\n\n    # sum(..., 1)\n    x5 = x4.rolling(1).sum()\n\n    # log(...)\n    x6 = np.log(x5 + 1e-8)\n\n    # rank(rank(log(...)))\n    x7 = x6.rank(axis=1, pct=True)\n    x8 = x7.rank(axis=1, pct=True)\n\n    # product(..., 1)\n    x9 = x8.rolling(1).apply(np.prod, raw=True)\n\n    # rank(product(...,1))\n    x10 = x9.rank(axis=1, pct=True)\n\n    # product(rank(...), 1)\n    x11 = x10.rolling(1).apply(np.prod, raw=True)\n\n    # min(product(...,1), 5)  (ts_min over 5)\n    part1 = x11.rolling(5).min()\n\n    # ts_rank(delay(-1 * returns, 6), 5)\n    y0 = (-1.0 * returns).shift(delay_d)\n    part2 = y0.rolling(ts_rank_d).apply(lambda s: s.rank().iloc[-1] / len(s), raw=False)\n\n    alpha = part1 + part2\n    alpha = alpha.dropna(how=\"all\")\n    return alpha"
  },
  {
    "factor_ref": "/Users/huangyuanhao/projects/autonomous_trading/factors/cross_sectional/wq_091.md",
    "name": "WQ-091: Distance from 5-day max times ranked volume-low correlation",
    "category": "cross_sectional",
    "formula": "-1 * rank(close - max(close, 5)) * rank(correlation(sma(volume, 40), low, 5))",
    "verdict": "FAIL",
    "reasons": [
      "FAIL: |IC| 0.0041 < 0.01",
      "FAIL: monotonicity 0.00 < 0.50"
    ],
    "error": null,
    "metrics": {
      "mean_ic": 0.004144812109916547,
      "ic_t_stat": 0.48622843001002597,
      "monotonicity": 0.0,
      "long_short_spread": -0.006659545324158831,
      "group_mean_returns": {
        "1": 0.004253524030744337,
        "2": 0.0007623198250354596,
        "3": -0.0024060212934144945
      },
      "n_groups": 3
    },
    "params": {
      "max_lookback": 5,
      "vol_sma": 40,
      "corr_lookback": 5
    },
    "param_ranges": {
      "max_lookback": [
        3,
        10
      ],
      "vol_sma": [
        20,
        60
      ],
      "corr_lookback": [
        3,
        10
      ]
    },
    "code": "import numpy as np\nimport pandas as pd\n\ndef compute_alpha(universe_data: dict[str, pd.DataFrame], **params) -> pd.DataFrame:\n    \"\"\"Returns DataFrame(index=dates, columns=tickers, values=alpha).\"\"\"\n    max_lookback = params.get(\"max_lookback\", 5)\n    vol_sma = params.get(\"vol_sma\", 40)\n    corr_lookback = params.get(\"corr_lookback\", 5)\n\n    close = pd.DataFrame({t: d[\"Close\"] for t, d in universe_data.items()})\n    low = pd.DataFrame({t: d[\"Low\"] for t, d in universe_data.items()})\n    volume = pd.DataFrame({t: d[\"Volume\"] for t, d in universe_data.items()}).astype(float)\n\n    close, low = close.align(low, join=\"inner\", axis=0)\n    close, volume = close.align(volume, join=\"inner\", axis=0)\n    low = low.reindex(close.index)\n\n    ts_max_close = close.rolling(max_lookback).max()\n    dist_from_max = close - ts_max_close\n    r1 = dist_from_max.rank(axis=1, pct=True)\n\n    vol_sma_ = volume.rolling(vol_sma).mean()\n    corr_vlow = vol_sma_.rolling(corr_lookback).corr(low)\n    r2 = corr_vlow.rank(axis=1, pct=True)\n\n    alpha = -1.0 * r1 * r2\n    return alpha.dropna(how=\"all\")"
  },
  {
    "factor_ref": "/Users/huangyuanhao/projects/autonomous_trading/factors/cross_sectional/wq_136.md",
    "name": "WQ-136: Ranked return acceleration times open-volume correlation",
    "category": "cross_sectional",
    "formula": "rank(delta(returns, 3)) * correlation(open, volume, 10) * -1",
    "verdict": "MARGINAL",
    "reasons": [
      "MARGINAL: |IC| 0.0177 < 0.03"
    ],
    "error": null,
    "metrics": {
      "mean_ic": -0.017726711097340208,
      "ic_t_stat": -2.073603911684804,
      "monotonicity": 0.5,
      "long_short_spread": 0.0008138049929470479,
      "group_mean_returns": {
        "1": 0.0012437227239554807,
        "2": -0.0013563123593397356,
        "3": 0.0020575277169025286
      },
      "n_groups": 3
    },
    "params": {
      "delta_d": 3,
      "corr_lookback": 10
    },
    "param_ranges": {
      "delta_d": [
        2,
        5
      ],
      "corr_lookback": [
        5,
        20
      ]
    },
    "code": "import numpy as np\nimport pandas as pd\n\ndef compute_alpha(universe_data: dict[str, pd.DataFrame], **params) -> pd.DataFrame:\n    \"\"\"Returns DataFrame(index=dates, columns=tickers, values=alpha).\"\"\"\n    delta_d = params.get(\"delta_d\", 3)\n    corr_lookback = params.get(\"corr_lookback\", 10)\n\n    close = pd.DataFrame({t: d[\"Close\"] for t, d in universe_data.items()})\n    open_ = pd.DataFrame({t: d[\"Open\"] for t, d in universe_data.items()})\n    volume = pd.DataFrame({t: d[\"Volume\"] for t, d in universe_data.items()}).astype(float)\n\n    close, open_ = close.align(open_, join=\"inner\", axis=0)\n    close, volume = close.align(volume, join=\"inner\", axis=0)\n    open_ = open_.reindex(close.index)\n\n    returns = close.pct_change(1)\n    ret_accel = returns.diff(delta_d)\n    ranked_ret_accel = ret_accel.rank(axis=1, pct=True)\n\n    ov_corr = open_.rolling(corr_lookback).corr(volume)\n\n    alpha = ranked_ret_accel * ov_corr * -1.0\n    return alpha.dropna(how=\"all\")"
  }
]