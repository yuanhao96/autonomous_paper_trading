# stratgen v1.1

**Alpha factor discovery, optimization, and signal generation for autonomous trading.**

v1.1 pivots from the strategy-based pipeline (v1.0) to structured alpha factors. Instead of having an LLM extract specs from free-form strategy descriptions, factor docs now follow a fixed markdown format that can be parsed deterministically. The LLM is only used for code generation, and that code is cached — making optimize and signals stages completely LLM-free.

```
python -m stratgen discover    # factor docs → LLM codegen → backtest → evaluate
python -m stratgen optimize    # grid search on train split, evaluate on test split
python -m stratgen signals     # generate current LONG/FLAT signals from top factors
python -m stratgen status      # show Alpaca account and positions
```

---

## Table of Contents

1. [What Changed from v1.0](#what-changed-from-v10)
2. [How It Works](#how-it-works)
3. [Factor Knowledge Base](#factor-knowledge-base)
4. [Architecture](#architecture)
5. [Pipeline Stages](#pipeline-stages)
6. [Installation](#installation)
7. [Configuration](#configuration)
8. [Usage](#usage)
9. [Data Formats](#data-formats)
10. [Design Decisions](#design-decisions)
11. [Limitations](#limitations)

---

## What Changed from v1.0

| Aspect | v1.0 | v1.1 |
|--------|------|------|
| **Knowledge source** | 92 free-form strategy docs | 115 structured alpha factor docs |
| **Spec extraction** | LLM-based (2 LLM calls/strategy) | Deterministic regex parsing (0 LLM calls) |
| **Code caching** | None — code generated fresh each run | Cached in `results_factors.json` |
| **LLM usage** | discover (2 calls), optimize (1 call) | discover only (1 call for codegen) |
| **Optimize** | LLM extracts param ranges | Param ranges parsed from factor docs |
| **Train/test split** | 2020–mid-2023 / mid-2023+ | 2020–2023 / 2024+ |
| **Data type** | `StrategySpec` | `FactorSpec` |
| **Result files** | `results_v4.json`, `results_v5.json` | `results_factors.json`, `results_factors_opt.json` |
| **Modules** | spec.py, backtest.py, discover.py, optimize.py | factor_discover.py, factor_optimize.py, factor_signals.py |
| **Order execution** | `run` command with Alpaca orders | Not yet wired (signals only) |

---

## How It Works

```
  Factor doc (.md)            "WQ-002: -1 * delta(log(close), 2)"
        │
        ▼
  Deterministic parse          FactorSpec(name="WQ-002",
        │                                formula="-1 * delta(log(close), 2)",
        │                                params={"lookback": 2},
        │                                param_ranges={"lookback": [1, 4]})
        ▼
  LLM: generate code           class GeneratedStrategy(Strategy): ...
        │                      (cached in results_factors.json)
        ▼
  backtesting.py                Backtest(df, GeneratedStrategy, cash=100_000)
        │
        ▼
  Evaluate                      PASS (Sharpe 0.45, 12 trades, -8.2% drawdown)
        │
        ▼
  Optimize (grid search)        Train: 2020–2023 | Test: 2024+
        │                       (reuses cached code, no LLM)
        ▼
  Signals                       LONG / FLAT per factor
```

### Constraints

- **Single ticker only** (SPY) — no multi-asset portfolios or cross-sectional ranking
- **OHLCV price data only** — no fundamentals, sentiment, or alternative data
- **Daily timeframe** — no intraday
- **Long-only** — alpha > 0 → LONG, alpha <= 0 → FLAT
- **backtesting.py engine** — technical indicators computed from price arrays

---

## Factor Knowledge Base

115 alpha factor formulas across 7 categories, sourced primarily from Kakushadze (2015) "101 Formulaic Alphas":

| Category | Count | Description |
|----------|-------|-------------|
| Momentum | 34 | Price momentum, returns, trend acceleration |
| Volume-Price | 25 | Volume-price divergence, confirmation |
| Mean Reversion | 15 | Z-scores, RSI-like, oscillators |
| Volatility | 13 | Range, dispersion, vol regime |
| Price Channel | 13 | Donchian, breakout, support/resistance |
| Trend | 12 | Directional, ADX-like, persistence |
| Composite | 3 | Multi-factor blends |

### Factor doc format

Each factor is a `.md` file under `factors/<category>/`:

```markdown
# WQ-002: Negative 2-day log return

## Formula
-1 * delta(log(close), 2)

## Interpretation
Contrarian short-term reversal on price momentum.

## Parameters
| Param | Default | Range |
|-------|---------|-------|
| lookback | 2 | [1, 4] |

## Category
momentum

## Source
WorldQuant Alpha#002 (Kakushadze 2015)
```

Factors without tunable parameters have `Parameters: None`.

---

## Architecture

```
src/stratgen/
├── cli.py              ─── Unified entry point, argparse subcommands
├── paths.py            ─── PROJECT_ROOT, FACTORS_DIR, result file paths
├── core.py             ─── FactorSpec, llm_call(), codegen, evaluate()
├── factor_discover.py  ─── Parse factor docs → codegen → backtest → evaluate
├── factor_optimize.py  ─── Grid search optimization with train/test split
├── factor_signals.py   ─── Signal generation from top optimized factors
└── trade.py            ─── Alpaca: account status
```

### Module dependency graph

```
cli.py
  ├── factor_discover.py  →  core.py, paths.py
  ├── factor_optimize.py  →  core.py, paths.py
  ├── factor_signals.py   →  core.py, paths.py
  └── trade.py            →  (alpaca-py)
```

All modules import from `core.py` (shared primitives) and `paths.py` (constants). No module has import-time side effects.

### Key data types

**FactorSpec** — parsed from factor docs:

```python
@dataclass
class FactorSpec:
    name: str                    # "WQ-002: Negative 2-day log return"
    formula: str                 # "-1 * delta(log(close), 2)"
    interpretation: str          # "Contrarian short-term reversal"
    params: dict                 # {"lookback": 2}
    param_ranges: dict           # {"lookback": [1, 4]}
    category: str                # "momentum"
    source: str                  # "WorldQuant Alpha#002"
    factor_ref: str              # "factors/momentum/wq_002.md"
```

**Verdict** — evaluation result:

| Verdict | Criteria |
|---------|----------|
| **PASS** | Sharpe >= 0.3, drawdown >= -30%, return >= 0%, trades >= 3 |
| **MARGINAL** | No hard fails, but doesn't meet all PASS thresholds |
| **FAIL** | Sharpe < 0, drawdown < -50%, return < 0%, or trades < 3 |
| **ERROR** | Exception during codegen or backtesting |

---

## Pipeline Stages

### Stage 1: Discover

**Command:** `python -m stratgen discover [--reset] [--provider openai|anthropic]`

Processes all 115 factor docs:

1. **Parse** — Regex-based extraction of FactorSpec from the fixed markdown format. No LLM needed.
2. **Code generation** — The LLM generates a `GeneratedStrategy` class from the formula. The code is cached in the result.
3. **Backtest** — Runs on SPY 2020–2025 daily data, $100k starting capital, 0.1% commission.
4. **Evaluate** — Applies pass/fail thresholds.
5. **Save** — Results (including generated code) saved to `results_factors.json` after every factor for resume.

### Stage 2: Optimize

**Command:** `python -m stratgen optimize [--reset] [--max-tries 200]`

Takes PASS and MARGINAL factors from discover and optimizes their parameters. **No LLM calls** — uses cached code and param ranges from the factor docs.

1. **Filter** — Select factors with verdict PASS or MARGINAL, non-empty code, and tunable params.
2. **Passthrough** — Factors with no params (`params: {}`) pass through with their discover stats.
3. **Train/test split** — Train on 2020-01-01 to 2023-12-31, test on 2024-01-01+.
4. **Grid search** — For each factor, generate a param grid from its `param_ranges`. If total combos exceed `--max-tries`, step sizes are coarsened. Run `bt.run(**combo)` for each combo on the train set, pick best by Sharpe.
5. **Test evaluation** — Evaluate best params on the held-out test set with the same thresholds.
6. **Save** — Results saved to `results_factors_opt.json` with resume support.

### Stage 3: Signals

**Command:** `python -m stratgen signals [--top-n 5]`

Generates current trading signals. **No LLM calls.**

1. **Rank** — Load optimized results, filter to test_verdict == PASS, sort by test Sharpe, take top N.
2. **Run** — For each factor, run its cached code on SPY data from 2024-01-01 to today with optimized params.
3. **Signal** — If the last trade is still open (ExitTime is NaT) → LONG. Otherwise → FLAT.
4. **Consensus** — Print per-factor signals and an overall LONG/FLAT/MIXED consensus.

### Stage 4: Status

**Command:** `python -m stratgen status`

Shows Alpaca paper trading account balance and current positions.

---

## Installation

```bash
git clone <repo-url> && cd autonomous_trading
pip install -e .

# With dev tools (ruff, mypy, pytest)
pip install -e ".[dev]"
```

**Requirements:** Python 3.10+

**Dependencies:** anthropic, alpaca-py, backtesting, openai, pandas, python-dotenv, yfinance

---

## Configuration

Create a `.env` file in the project root:

```
# At least one LLM provider (required for discover)
OPENAI_API_KEY=sk-...
ANTHROPIC_API_KEY=sk-ant-...

# Required for status command
ALPACA_API_KEY=PK...
ALPACA_SECRET_KEY=...
```

---

## Usage

```bash
# Discover — generate and backtest all factor code
python -m stratgen discover
python -m stratgen discover --reset
python -m stratgen discover --provider anthropic

# Optimize — grid search params on train/test split
python -m stratgen optimize
python -m stratgen optimize --reset
python -m stratgen optimize --max-tries 500

# Signals — generate LONG/FLAT from top factors
python -m stratgen signals
python -m stratgen signals --top-n 3

# Status — Alpaca account info
python -m stratgen status
```

---

## Data Formats

### results_factors.json (discover)

```json
{
  "factor_ref": "factors/momentum/wq_002.md",
  "name": "WQ-002: Negative 2-day log return",
  "category": "momentum",
  "formula": "-1 * delta(log(close), 2)",
  "params": {"lookback": 2},
  "param_ranges": {"lookback": [1, 4]},
  "code": "import pandas as pd\nimport numpy as np\nfrom backtesting import Strategy\n...",
  "verdict": "PASS",
  "reasons": ["Sharpe 0.45, 12 trades, dd -8.2%, return 25.3%"],
  "error": null,
  "stats": {
    "Return [%]": 25.3,
    "Sharpe Ratio": 0.45,
    "Max. Drawdown [%]": -8.2,
    "# Trades": 12
  }
}
```

### results_factors_opt.json (optimize)

```json
{
  "factor_ref": "factors/momentum/wq_002.md",
  "name": "WQ-002: Negative 2-day log return",
  "category": "momentum",
  "formula": "-1 * delta(log(close), 2)",
  "code": "...",
  "original_params": {"lookback": 2},
  "param_ranges": {"lookback": [1, 4]},
  "optimized_params": {"lookback": 3},
  "train_stats": { "Sharpe Ratio": 0.55, ... },
  "test_stats": { "Sharpe Ratio": 0.42, "Return [%]": 18.1, ... },
  "test_verdict": "PASS",
  "test_reasons": ["Sharpe 0.42, 8 trades, dd -6.5%, return 18.1%"],
  "error": null
}
```

---

## Design Decisions

**Why alpha factors instead of strategy docs?**
v1.0's strategy docs were free-form text requiring LLM interpretation for spec extraction. This introduced non-determinism and errors. Alpha factors have a fixed formula + params format that can be parsed with regex, making the pipeline more reliable and reproducible.

**Why cache generated code?**
In v1.0, code was regenerated on every run — expensive and non-deterministic. Caching code in the discover results means optimize and signals are LLM-free, faster, and deterministic.

**Why train/test split at 2024?**
4 years of training data (2020–2023) and 1+ years of test data (2024+). The 2024 boundary avoids look-ahead bias and gives enough recent data for meaningful out-of-sample evaluation.

**Why grid search instead of backtesting.py's optimizer?**
backtesting.py's built-in `bt.optimize()` doesn't support train/test splits. We need to grid search on train data and evaluate on test data separately to guard against overfitting.

**Why cap at --max-tries?**
Factors with 5+ params can produce thousands of combos. The `build_param_grid()` function auto-coarsens step sizes when total combos exceed the budget, keeping runtime practical.

**Why passthrough for no-param factors?**
Some factors (e.g., WQ-011) have `Parameters: None`. There's nothing to optimize, so they pass through with their discover verdict and stats.

---

## Limitations

- **No order execution.** v1.1 generates signals but does not submit orders. The `run` command from v1.0 is not yet wired to the factor pipeline.

- **Single ticker (SPY) only.** All factors are backtested on SPY daily data. Multi-asset or cross-sectional factors are excluded.

- **Code generation is non-deterministic.** Even at temperature=0, LLM outputs may vary between runs. Cached code mitigates this for optimize/signals but not for re-discovery.

- **Signal extraction is approximate.** Current signals check whether the last backtest trade is still open. This may miss signals in factors with rapid position changes.

- **No portfolio-level risk management.** Signals are per-factor with no cross-factor correlation analysis or portfolio-level drawdown limits.

- **Integer params only in grid search.** The grid builder generates integer ranges for most params. Float-valued params get 10 discrete steps, which may miss optimal values.
